<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Criterion.rs Documentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="User Guide and Other Prose Documentation For Criterion.rs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="criterion_rs.html"><strong aria-hidden="true">1.</strong> Criterion.rs</a></li><li><ol class="section"><li><a href="getting_started.html"><strong aria-hidden="true">1.1.</strong> Getting Started</a></li></ol></li><li><a href="user_guide/user_guide.html"><strong aria-hidden="true">2.</strong> User Guide</a></li><li><ol class="section"><li><a href="user_guide/migrating_from_libtest.html"><strong aria-hidden="true">2.1.</strong> Migrating from libtest</a></li><li><a href="user_guide/command_line_output.html"><strong aria-hidden="true">2.2.</strong> Command-Line Output</a></li><li><a href="user_guide/command_line_options.html"><strong aria-hidden="true">2.3.</strong> Command-Line Options</a></li><li><a href="user_guide/html_report.html"><strong aria-hidden="true">2.4.</strong> HTML Report</a></li><li><a href="user_guide/plots_and_graphs.html"><strong aria-hidden="true">2.5.</strong> Plots &amp; Graphs</a></li><li><a href="user_guide/benchmarking_with_inputs.html"><strong aria-hidden="true">2.6.</strong> Benchmarking With Inputs</a></li><li><a href="user_guide/advanced_configuration.html"><strong aria-hidden="true">2.7.</strong> Advanced Configuration</a></li><li><a href="user_guide/comparing_functions.html"><strong aria-hidden="true">2.8.</strong> Comparing Functions</a></li><li><a href="user_guide/external_programs.html"><strong aria-hidden="true">2.9.</strong> Benchmarking External Programs</a></li><li><a href="user_guide/csv_output.html"><strong aria-hidden="true">2.10.</strong> CSV Output</a></li><li><a href="user_guide/known_limitations.html"><strong aria-hidden="true">2.11.</strong> Known Limitations</a></li><li><a href="user_guide/bencher_compatibility.html"><strong aria-hidden="true">2.12.</strong> Bencher Compatibility Layer</a></li><li><a href="user_guide/timing_loops.html"><strong aria-hidden="true">2.13.</strong> Timing Loops</a></li></ol></li><li><a href="analysis.html"><strong aria-hidden="true">3.</strong> Analysis Process</a></li><li><a href="faq.html"><strong aria-hidden="true">4.</strong> Frequently Asked Questions</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Criterion.rs Documentation</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#criterionrs" id="criterionrs"><h1>Criterion.rs</h1></a>
<p>Criterion.rs is a statistics-driven micro-benchmarking tool. It is a Rust port of <a href="https://hackage.haskell.org/package/criterion">Haskell's Criterion</a> library.</p>
<p>Criterion.rs benchmarks collect and store statistical information from run to run and can automatically detect performance regressions as well as measuring optimizations.</p>
<p>Criterion.rs is free and open source. You can find the source on <a href="https://github.com/bheisler/criterion.rs">GitHub</a>. Issues and feature requests can be posted on <a href="https://github.com/bheisler/criterion.rs/issues">the issue tracker</a>.</p>
<a class="header" href="#api-docs" id="api-docs"><h2>API Docs</h2></a>
<p>In addition to this book, you may also wish to read <a href="http://bheisler.github.io/criterion.rs/criterion/">the API documentation</a>.</p>
<a class="header" href="#license" id="license"><h2>License</h2></a>
<p>Criterion.rs is dual-licensed under the <a href="https://github.com/bheisler/criterion.rs/blob/master/LICENSE-APACHE">Apache 2.0</a> and the <a href="https://github.com/bheisler/criterion.rs/blob/master/LICENSE-MIT">MIT</a> licenses.</p>
<a class="header" href="#debug-output" id="debug-output"><h2>Debug Output</h2></a>
<p>To enable debug output in Criterion.rs, define the environment variable <code>CRITERION_DEBUG</code>. For example (in bash):</p>
<pre><code class="language-bash">CRITERION_DEBUG=1 cargo bench
</code></pre>
<p>This will enable extra debug output. Criterion.rs will also save the gnuplot scripts alongside the generated plot files. When raising issues with Criterion.rs (especially when reporting issues with the plot generation) please run your benchmarks with this option enabled and provide the additional output and relevant gnuplot scripts.</p>
<a class="header" href="#getting-started" id="getting-started"><h1>Getting Started</h1></a>
<a class="header" href="#step-1---add-dependency-to-cargotoml" id="step-1---add-dependency-to-cargotoml"><h3>Step 1 - Add Dependency to cargo.toml</h3></a>
<p>To enable Criterion.rs benchmarks, add the following to your <code>cargo.toml</code> file:</p>
<pre><code class="language-toml">[dev-dependencies]
criterion = &quot;0.2&quot;

[[bench]]
name = &quot;my_benchmark&quot;
harness = false
</code></pre>
<p>This adds a development dependency on Criterion.rs, and declares a benchmark called <code>my_benchmark</code> without the standard benchmarking harness. It's important to disable the standard benchmark harness, because we'll later add our own and we don't want them to conflict.</p>
<a class="header" href="#step-2---add-benchmark" id="step-2---add-benchmark"><h3>Step 2 - Add Benchmark</h3></a>
<p>As an example, we'll benchmark an implementation of the Fibonacci function. Create a benchmark file at <code>$PROJECT/benches/my_benchmark.rs</code> with the following contents (see the Details section below for an explanation of this code):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate criterion;

use criterion::Criterion;

fn fibonacci(n: u64) -&gt; u64 {
    match n {
        0 =&gt; 1,
        1 =&gt; 1,
        n =&gt; fibonacci(n-1) + fibonacci(n-2),
    }
}

fn criterion_benchmark(c: &amp;mut Criterion) {
    c.bench_function(&quot;fib 20&quot;, |b| b.iter(|| fibonacci(20)));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
#}</code></pre></pre>
<a class="header" href="#step-3---run-benchmark" id="step-3---run-benchmark"><h3>Step 3 - Run Benchmark</h3></a>
<p>To run this benchmark, use the following command:</p>
<p><code>cargo bench</code></p>
<p>You should see output similar to this:</p>
<pre><code>     Running target/release/deps/example-423eedc43b2b3a93
Benchmarking fib 20
Benchmarking fib 20: Warming up for 3.0000 s
Benchmarking fib 20: Collecting 100 samples in estimated 5.0658 s (188100 iterations)
Benchmarking fib 20: Analyzing
fib 20                  time:   [26.029 us 26.251 us 26.505 us]
Found 11 outliers among 99 measurements (11.11%)
  6 (6.06%) high mild
  5 (5.05%) high severe
slope  [26.029 us 26.505 us] R^2            [0.8745662 0.8728027]
mean   [26.106 us 26.561 us] std. dev.      [808.98 ns 1.4722 us]
median [25.733 us 25.988 us] med. abs. dev. [234.09 ns 544.07 ns]
</code></pre>
<a class="header" href="#details" id="details"><h3>Details</h3></a>
<p>Let's go back and walk through that benchmark code in more detail.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro use]
extern crate criterion;

use criterion::Criterion;
#}</code></pre></pre>
<p>First, we declare the criterion crate and import the <a href="http://bheisler.github.io/criterion.rs/criterion/struct.Criterion.html">Criterion type</a>. Criterion is the main type for the Criterion.rs library. It provides methods to configure and define groups of benchmarks.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn fibonacci(n: u64) -&gt; u64 {
    match n {
        0 =&gt; 1,
        1 =&gt; 1,
        n =&gt; fibonacci(n-1) + fibonacci(n-2),
    }
}
#}</code></pre></pre>
<p>Second, we define the function to benchmark. In normal usage, this would be imported from elsewhere in your crate, but for simplicity we'll just define it right here.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn criterion_benchmark(c: &amp;mut Criterion) {
#}</code></pre></pre>
<p>Here we create a function to contain our benchmark code. The name of the benchmark function doesn't matter, but it should be clear and understandable.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    c.bench_function(&quot;fib 20&quot;, |b| b.iter(|| fibonacci(20)));
}
#}</code></pre></pre>
<p>This is where the real work happens. The <code>bench_function</code> method defines a benchmark with a name and a closure. The name should be unique among all of the benchmarks for your project. The closure must accept one argument, a <a href="http://bheisler.github.io/criterion.rs/criterion/struct.Bencher.html">Bencher</a>. The bencher performs the benchmark - in this case, it simply calls our <code>fibonacci</code> function in a loop. There are a number of other benchmark functions, including the option to benchmark with arguments, to benchmark external programs and to compare the performance of two functions. See the API documentation for details on all of the different benchmarking options.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
#}</code></pre></pre>
<p>Here we invoke the <code>criterion_group!</code> <a href="http://bheisler.github.io/criterion.rs/criterion/macro.criterion_group.html">(link)</a> macro to generate a benchmark group called benches, containing the <code>criterion_benchmark</code> function defined earlier. Finally, we invoke the <code>criterion_main!</code> <a href="http://bheisler.github.io/criterion.rs/criterion/macro.criterion_main.html">(link)</a> macro to generate a main function which executes the <code>benches</code> group. See the API documentation for more information on these macros.</p>
<a class="header" href="#step-4---optimize" id="step-4---optimize"><h3>Step 4 - Optimize</h3></a>
<p>This fibonacci function is quite inefficient. We can do better:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn fibonacci(n: u64) -&gt; u64 {
    let mut a = 0u64;
    let mut b = 1u64;
    let mut c = 0u64;

    if n == 0 {
        return 0
    }

    for _ in 0..(n+1) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}
#}</code></pre></pre>
<p>Running the benchmark now produces output like this:</p>
<pre><code>     Running target/release/deps/example-423eedc43b2b3a93
Benchmarking fib 20
Benchmarking fib 20: Warming up for 3.0000 s
Benchmarking fib 20: Collecting 100 samples in estimated 5.0000 s (13548862800 iterations)
Benchmarking fib 20: Analyzing
fib 20                  time:   [353.59 ps 356.19 ps 359.07 ps]
                        change: [-99.999% -99.999% -99.999%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 6 outliers among 99 measurements (6.06%)
  4 (4.04%) high mild
  2 (2.02%) high severe
slope  [353.59 ps 359.07 ps] R^2            [0.8734356 0.8722124]
mean   [356.57 ps 362.74 ps] std. dev.      [10.672 ps 20.419 ps]
median [351.57 ps 355.85 ps] med. abs. dev. [4.6479 ps 10.059 ps]
</code></pre>
<p>As you can see, Criterion is statistically confident that our optimization has made an improvement. If we introduce a performance regression, Criterion will instead print a message indicating this.</p>
<a class="header" href="#user-guide" id="user-guide"><h1>User Guide</h1></a>
<p>This chapter covers the output produced by Criterion.rs benchmarks, both the command-line reports and the charts. It also details more advanced usages of Criterion.rs such as benchmarking external programs and comparing the performance of multiple functions.</p>
<a class="header" href="#migrating-from-libtest" id="migrating-from-libtest"><h1>Migrating from libtest</h1></a>
<p>This page shows an example of converting a libtest or bencher benchmark to use
Criterion.rs.</p>
<a class="header" href="#the-benchmark" id="the-benchmark"><h2>The Benchmark</h2></a>
<p>We'll start with this benchmark as an example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(test)]
#fn main() {
extern crate test;
use test::Bencher;

fn fibonacci(n: u64) -&gt; u64 {
    match n {
        0 =&gt; 1,
        1 =&gt; 1,
        n =&gt; fibonacci(n-1) + fibonacci(n-2),
    }
}

#[bench]
fn bench_fib(b: &amp;mut Bencher) {
    b.iter(|| fibonacci(20));
}
#}</code></pre></pre>
<a class="header" href="#the-migration" id="the-migration"><h2>The Migration</h2></a>
<p>The first thing to do is update the <code>Cargo.toml</code> to disable the libtest
benchmark harness:</p>
<pre><code class="language-toml">[[bench]]
name = &quot;example&quot;
harness = false
</code></pre>
<p>We also need to add Criterion.rs to the <code>dev-dependencies</code> section of <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
criterion = &quot;0.2&quot;
</code></pre>
<p>The next step is to update the imports:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate criterion;
use criterion::Criterion;
#}</code></pre></pre>
<p>Then, we can change the <code>bench_fib</code> function. Remove the <code>#[bench]</code> and change
the argument to <code>&amp;mut Criterion</code> instead. The contents of this function need to
change as well:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn bench_fib(c: &amp;mut Criterion) {
    c.bench_function(&quot;fib 20&quot;, |b| b.iter(|| fibonacci(20)));
}
#}</code></pre></pre>
<p>Finally, we need to invoke some macros to generate a main function, since we
no longer have libtest to provide one:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
criterion_group!(benches, bench_fib);
criterion_main!(benches);
#}</code></pre></pre>
<p>And that's it! The complete migrated benchmark code is below:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate criterion;
use criterion::Criterion;

fn fibonacci(n: u64) -&gt; u64 {
    match n {
        0 =&gt; 1,
        1 =&gt; 1,
        n =&gt; fibonacci(n-1) + fibonacci(n-2),
    }
}

fn bench_fib(c: &amp;mut Criterion) {
    c.bench_function(&quot;fib 20&quot;, |b| b.iter(|| fibonacci(20)));
}

criterion_group!(benches, bench_fib);
criterion_main!(benches);
#}</code></pre></pre>
<a class="header" href="#command-line-output" id="command-line-output"><h1>Command-Line Output</h1></a>
<p>The output for this page was produced by running <code>cargo bench -- --verbose</code>. <code>cargo bench</code> omits
some of this information. Note: If <code>cargo bench</code> fails with an error message about an unknown
argument, see <a href="../faq.html#cargo-bench-gives-unrecognized-option-errors-for-valid-command-line-options">the
FAQ</a>.</p>
<p>Every Criterion.rs benchmark calculates statistics from the measured iterations and produces a report like this:</p>
<pre><code>Benchmarking alloc
Benchmarking alloc: Warming up for 1.0000 s
Benchmarking alloc: Collecting 100 samples in estimated 13.354 s (5050 iterations)
Benchmarking alloc: Analyzing
alloc                   time:   [2.5094 ms 2.5306 ms 2.5553 ms]
                        thrpt:  [391.34 MiB/s 395.17 MiB/s 398.51 MiB/s]
                        change: [-38.292% -37.342% -36.524%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 8 outliers among 100 measurements (8.00%)
  4 (4.00%) high mild
  4 (4.00%) high severe
slope  [2.5094 ms 2.5553 ms] R^2            [0.8660614 0.8640630]
mean   [2.5142 ms 2.5557 ms] std. dev.      [62.868 us 149.50 us]
median [2.5023 ms 2.5262 ms] med. abs. dev. [40.034 us 73.259 us]
</code></pre>
<a class="header" href="#warmup" id="warmup"><h2>Warmup</h2></a>
<p>Every Criterion.rs benchmark iterates the benchmarked function automatically for a configurable warmup period (by default, for three seconds). For Rust function benchmarks, this is to warm up the processor caches and (if applicable) file system caches. For external program benchmarks, it can also be used to warm up JIT compilers.</p>
<a class="header" href="#collecting-samples" id="collecting-samples"><h2>Collecting Samples</h2></a>
<p>Criterion iterates the function to be benchmarked with a varying number of iterations to generate an estimate of the time taken by each iteration. The number of samples is configurable. It also prints an estimate of the time the sampling process will take based on the time per iteration during the warmup period.</p>
<a class="header" href="#time" id="time"><h2>Time</h2></a>
<pre><code>time:   [2.5094 ms 2.5306 ms 2.5553 ms]
thrpt:  [391.34 MiB/s 395.17 MiB/s 398.51 MiB/s]
</code></pre>
<p>This shows a confidence interval over the measured per-iteration time for this benchmark. The left and right values show the lower and upper bounds of the confidence interval respectively, while the center value shows Criterion.rs' best estimate of the time taken for each iteration of the benchmarked routine.</p>
<p>The confidence level is configurable. A greater confidence level (eg. 99%) will widen the interval and thus provide the user with less information about the true slope. On the other hand, a lesser confidence interval (eg. 90%) will narrow the interval but then the user is less confident that the interval contains the true slope. 95% is generally a good balance.</p>
<p>Criterion.rs performs <a href="https://en.wikipedia.org/wiki/Bootstrapping_(statistics)">bootstrap resampling</a> to generate these confidence intervals. The number of bootstrap samples is configurable, and defaults to 100,000.</p>
<p>Optionally, Criterion.rs can also report the throughput of the benchmarked code in units of bytes or elements per second.</p>
<a class="header" href="#change" id="change"><h2>Change</h2></a>
<p>When a Criterion.rs benchmark is run, it saves statistical information in the <code>target/criterion</code> directory. Subsequent executions of the benchmark will load this data and compare it with the current sample to show the effects of changes in the code.</p>
<pre><code>change: [-38.292% -37.342% -36.524%] (p = 0.00 &lt; 0.05)
Performance has improved.
</code></pre>
<p>This shows a confidence interval over the difference between this run of the benchmark and the last one, as well as the probability that the measured difference could have occurred by chance. These lines will be omitted if no saved data could be read for this benchmark.</p>
<p>The second line shows a quick summary. This line will indicate that the performance has improved or regressed if Criterion.rs has strong statistical evidence that this is the case. It may also indicate that the change was within the noise threshold. Criterion.rs attempts to reduce the effects of noise as much as possible, but differences in benchmark environment (eg. different load from other processes, memory usage, etc.) can influence the results. For highly-deterministic benchmarks, Criterion.rs can be sensitive enough to detect these small fluctuations, so benchmark results that overlap the range <code>+-noise_threshold</code> are assumed to be noise and considered insignificant. The noise threshold is configurable, and defaults to <code>+-2%</code>.</p>
<p>Additional examples:</p>
<pre><code>alloc                   time:   [1.2421 ms 1.2540 ms 1.2667 ms]
                        change: [+40.772% +43.934% +47.801%] (p = 0.00 &lt; 0.05)
                        Performance has regressed.
</code></pre>
<pre><code>alloc                   time:   [1.2508 ms 1.2630 ms 1.2756 ms]
                        change: [-1.8316% +0.9121% +3.4704%] (p = 0.52 &gt; 0.05)
                        No change in performance detected.
</code></pre>
<pre><code>benchmark               time:   [442.92 ps 453.66 ps 464.78 ps]
                        change: [-0.7479% +3.2888% +7.5451%] (p = 0.04 &gt; 0.05)
                        Change within noise threshold.
</code></pre>
<a class="header" href="#detecting-outliers" id="detecting-outliers"><h2>Detecting Outliers</h2></a>
<pre><code>Found 8 outliers among 100 measurements (8.00%)
  4 (4.00%) high mild
  4 (4.00%) high severe
</code></pre>
<p>Criterion.rs attempts to detect unusually high or low samples and reports them as outliers. A large number of outliers suggests that the benchmark results are noisy and should be viewed with appropriate skepticism. In this case, you can see that there are some samples which took much longer than normal. This might be caused by unpredictable load on the computer running the benchmarks, thread or process scheduling, or irregularities in the time taken by the code being benchmarked.</p>
<p>In order to ensure reliable results, benchmarks should be run on a quiet computer and should be designed to do approximately the same amount of work for each iteration. If this is not possible, consider increasing the measurement time to reduce the influence of outliers on the results at the cost of longer benchmarking period. Alternately, the warmup period can be extended (to ensure that any JIT compilers or similar are warmed up) or other iteration loops can be used to perform setup before each benchmark to prevent that from affecting the results.</p>
<a class="header" href="#additional-statistics" id="additional-statistics"><h2>Additional Statistics</h2></a>
<pre><code>slope  [2.5094 ms 2.5553 ms] R^2            [0.8660614 0.8640630]
mean   [2.5142 ms 2.5557 ms] std. dev.      [62.868 us 149.50 us]
median [2.5023 ms 2.5262 ms] med. abs. dev. [40.034 us 73.259 us]
</code></pre>
<p>This shows additional confidence intervals based on other statistics.</p>
<p>Criterion.rs performs a linear regression to calculate the time per iteration. The first line shows the confidence interval of the slopes from the linear regressions, while the R^2 area shows the goodness-of-fit values for the lower and upper bounds of that confidence interval. If the R^2 value is low, this may indicate the benchmark isn't doing the same amount of work on each iteration. You may wish to examine the plot output and consider improving the consistency of your benchmark routine.</p>
<p>The second line shows confidence intervals on the mean and standard deviation of the per-iteration times (calculated naively). If std. dev. is large compared to the time values from above, the benchmarks are noisy. You may need to change your benchmark to reduce the noise.</p>
<p>The median/med. abs. dev. line is similar to the mean/std. dev. line, except that it uses the median and <a href="https://en.wikipedia.org/wiki/Median_absolute_deviation">median absolute deviation</a>. As with the std. dev., if the med. abs. dev. is large, this indicates the benchmarks are noisy.</p>
<a class="header" href="#a-note-of-caution" id="a-note-of-caution"><h2>A Note Of Caution</h2></a>
<p>Criterion.rs is designed to produce robust statistics when possible, but it can't account for everything. For example, the performance improvements and regressions listed in the above examples were created just by switching my laptop between battery power and wall power rather than changing the code under test. Care must be taken to ensure that benchmarks are performed under similar conditions in order to produce meaningful results.</p>
<a class="header" href="#command-line-options" id="command-line-options"><h1>Command-Line Options</h1></a>
<p>Criterion.rs benchmarks accept a number of custom command-line parameters. This
is a list of the most common options. Run <code>cargo bench -- -h</code> to see a full
list.</p>
<ul>
<li>To filter benchmarks, use <code>cargo bench -- &lt;filter&gt;</code> where <code>&lt;filter&gt;</code> is a
substring of the benchmark ID. For example, running <code>cargo bench -- fib_20</code>
would only run benchmarks whose ID contains the string <code>fib_20</code></li>
<li>To print more detailed output, use <code>cargo bench -- --verbose</code></li>
<li>To disable colored output, use <code>cargo bench -- --color never</code></li>
<li>To disable plot generation, use <code>cargo bench -- --noplot</code></li>
<li>To iterate each benchmark for a fixed length of time without saving, analyzing or plotting the results, use <code>cargo bench -- --profile-time &lt;num_seconds&gt;</code>. This is useful when profiling the benchmarks. It reduces the amount of unrelated clutter in the profiling results and prevents Criterion.rs' normal dynamic sampling logic from greatly increasing the runtime of the benchmarks.</li>
<li>To save a baseline, use <code>cargo bench -- --save-baseline &lt;name&gt;</code>. To compare against an existing baseline, use <code>cargo bench -- --baseline &lt;name&gt;</code>. For more on baselines, see below.</li>
<li>To test that the benchmarks run successfully without performing the measurement or analysis (eg. in a CI setting), use <code>cargo bench -- --test</code>.</li>
</ul>
<a class="header" href="#note" id="note"><h3>Note:</h3></a>
<p>If <code>cargo bench</code> fails with an error message about an unknown argument, see <a href="../faq.html#cargo-bench-gives-unrecognized-option-errors-for-valid-command-line-options">the FAQ</a>.</p>
<a class="header" href="#baselines" id="baselines"><h2>Baselines</h2></a>
<p>By default, Criterion.rs will compare the measurements against the previous run (if any). Sometimes it's useful to keep a set of measurements around for several runs. For example, you might want to make multiple changes to the code while comparing against the master branch. For this situation, Criterion.rs supports custom baselines.</p>
<ul>
<li><code>--save-baseline &lt;name&gt;</code> will compare against the named baseline, then overwrite it.</li>
<li><code>--baseline &lt;name&gt;</code> will compare against the named baseline without overwriting it.</li>
</ul>
<p>Using these options, you can manage multiple baseline measurements. For instance, if you want to compare against a static reference point such as the master branch, you might run:</p>
<pre><code class="language-sh">git checkout master
cargo bench -- --save-baseline master
git checkout optimizations
cargo bench -- --baseline master

# Some optimization work here

# Measure again and compare against the stored baseline without overwriting it
cargo bench -- --baseline master
</code></pre>
<a class="header" href="#html-report" id="html-report"><h1>HTML Report</h1></a>
<p>If <a href="http://www.gnuplot.info/">gnuplot</a> is installed, Criterion.rs can generate an HTML report displaying the results of the benchmark under <code>target/criterion/report/index.html</code>.</p>
<p>To see an example report, <a href="html_report/report/index.html">click here</a>. For more details on the charts and statistics displayed, check the other pages of this book.</p>
<a class="header" href="#plots--graphs" id="plots--graphs"><h1>Plots &amp; Graphs</h1></a>
<p>If <a href="http://www.gnuplot.info/">gnuplot</a> is installed, Criterion.rs can generate a number of useful
charts and graphs which you can check to get a better understanding of the behavior of the
benchmark.</p>
<a class="header" href="#file-structure" id="file-structure"><h2>File Structure</h2></a>
<p>The plots and saved data are stored under <code>target/criterion/$BENCHMARK_NAME/</code>. Here's an example of
the folder structure:</p>
<pre><code>$BENCHMARK/
├── base/
│  ├── raw.csv
│  ├── estimates.json
│  ├── sample.json
│  └── tukey.json
├── change/
│  └── estimates.json
├── new/
│  ├── raw.csv
│  ├── estimates.json
│  ├── sample.json
│  └── tukey.json
└── report/
   ├── both/
   │  ├── pdf.svg
   │  └── regression.svg
   ├── change/
   │  ├── mean.svg
   │  ├── median.svg
   │  └── t-test.svg
   ├── index.html
   ├── MAD.svg
   ├── mean.svg
   ├── median.svg
   ├── pdf.svg
   ├── pdf_small.svg
   ├── regression.svg
   ├── regression_small.svg
   ├── relative_pdf_small.svg
   ├── relative_regression_small.svg
   ├── SD.svg
   └── slope.svg
</code></pre>
<p>The <code>new</code> folder contains the statistics for the last benchmarking run, while the <code>base</code> folder
contains those for the last run on the <code>base</code> baseline (see <a href="user_guide/./command_line_options.html#baselines">Command-Line
Options</a> for more information on baselines). The plots are in
the <code>report</code> folder. Criterion.rs only keeps historical data for the last run. The <code>report/both</code>
folder contains plots which show both runs on one plot, while the <code>report/change</code> folder contains
plots showing the differences between the last two runs. This example shows the plots produced by
the default <code>bench_function</code> benchmark method. Other methods may produce additional charts, which
will be detailed in their respective pages.</p>
<a class="header" href="#madmeanmediansdslope" id="madmeanmediansdslope"><h2>MAD/Mean/Median/SD/Slope</h2></a>
<p><img src="./mean.svg" alt="Mean Chart" /></p>
<p>These are the simplest of the plots generated by Criterion.rs. They display the bootstrapped
distributions and confidence intervals for the given statistics.</p>
<a class="header" href="#regression" id="regression"><h2>Regression</h2></a>
<p><img src="./regression.svg" alt="Regression Chart" /></p>
<p>The regression plot shows each data point plotted on an X-Y plane showing the number of iterations
vs the time taken. It also shows the line representing Criterion.rs' best guess at the time per
iteration. A good benchmark will show the data points all closely following the line. If the data
points are scattered widely, this indicates that there is a lot of noise in the data and that the
benchmark may not be reliable. If the data points follow a consistent trend but don't match the
line (eg. if they follow a curved pattern or show several discrete line segments) this indicates
that the benchmark is doing different amounts of work depending on the number of iterations, which
prevents Criterion.rs from generating accurate statistics and means that the benchmark may need to
be reworked.</p>
<p>The combined regression plot in the <code>report/both</code> folder shows only the regression lines and is a
useful visual indicator of the difference in performance between the two runs.</p>
<a class="header" href="#pdf" id="pdf"><h2>PDF</h2></a>
<p><img src="./pdf.svg" alt="PDF Chart" /></p>
<p>The PDF chart shows the probability distribution function for the samples. It also shows the ranges
used to classify samples as outliers. In this example (as in the regression example above) we can
see that the performance trend changes noticeably below ~35 iterations, which we may wish to
investigate.</p>
<a class="header" href="#benchmarking-with-inputs" id="benchmarking-with-inputs"><h1>Benchmarking With Inputs</h1></a>
<p>Criterion.rs can run benchmarks with multiple different input values to investigate how the performance behavior changes with different inputs.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    static KB: usize = 1024;

    Criterion::default()
    .bench_function_over_inputs(&quot;from_elem&quot;, |b, &amp;&amp;size| {
        b.iter(|| iter::repeat(0u8).take(size).collect::&lt;Vec&lt;_&gt;&gt;());
    }, &amp;[KB, 2 * KB, 4 * KB, 8 * KB, 16 * KB])
#}</code></pre></pre>
<p>In this example, we're benchmarking the time it takes to collect a iterator producing a sequence of N bytes into a Vec. We use the <code>bench_function_over_inputs</code> method. Unlike <code>bench_function</code>, the lambda here takes a Bencher and a reference to a parameter, in this case <code>size</code>. Finally, we provide a slice of potential input values. This generates five benchmarks, named &quot;from_elem/1024&quot; through &quot;from_elem/16384&quot; which individually behave the same as any other benchmark. Criterion.rs also generates some charts in <code>target/criterion/from_elem/report/</code> showing how the iteration time changes as a function of the input.</p>
<p><img src="./line.svg" alt="Line Chart" /></p>
<p>Here we can see that there is a approximately-linear relationship between the length of an iterator and the time taken to collect it into a Vec.</p>
<a class="header" href="#advanced-configuration" id="advanced-configuration"><h1>Advanced Configuration</h1></a>
<p>Criterion.rs provides a number of configuration options for more-complex use cases. These options are documented here.</p>
<a class="header" href="#throughput-measurements" id="throughput-measurements"><h2>Throughput Measurements</h2></a>
<p>When benchmarking some types of code it is useful to measure the throughput as well as the iteration time, either in bytes per second or elements per second. Criterion.rs can estimate the throughput of a benchmark, but it needs to know how many bytes or elements each iteration will process.</p>
<p>Throughput measurements are only supported with using the <code>Benchmark</code> or <code>ParameterizedBenchmark</code> structures; it is not available when using the simpler <code>bench_function</code> interface.</p>
<p>To measure throughput, use the <code>throughput</code> method on <code>Benchmark</code>, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use criterion::*;

fn decode(bytes: &amp;[u8]) {
    // Decode the bytes
    ...
}

fn bench(c: &amp;mut Criterion) {
    let bytes : &amp;[u8] = ...;

    c.bench(
        &quot;throughput-example&quot;,
        Benchmark::new(
            &quot;decode&quot;,
            |b| b.iter(|| decode(bytes)),
        ).throughput(Throughput::Bytes(bytes.len() as u32)),
    );
}

criterion_group!(benches, bench);
criterion_main!(benches);
#}</code></pre></pre>
<p>For parameterized benchmarks, each argument might represent a different number of elements, so the throughput function accepts a lambda instead:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use criterion::*;

type Element = ...;

fn encode(elements: &amp;[Element]) {
    // Encode the elements
    ...
}

fn bench(c: &amp;mut Criterion) {
    let elements_1 : &amp;[u8] = ...;
    let elements_2 : &amp;[u8] = ...;

    c.bench(
        &quot;throughput-example&quot;,
        ParameterizedBenchmark::new(
            &quot;encode&quot;,
            |b, elems| b.iter(|| encode(elems)),
            vec![elements_1, elements_2],
        ).throughput(|elems| Throughput::Elements(elems.len() as u32)),
    );
}

criterion_group!(benches, bench);
criterion_main!(benches);
#}</code></pre></pre>
<p>Setting the throughput causes a throughput estimate to appear in the output:</p>
<pre><code>alloc                   time:   [5.9846 ms 6.0192 ms 6.0623 ms]
                        thrpt:  [164.95 MiB/s 166.14 MiB/s 167.10 MiB/s]  
</code></pre>
<a class="header" href="#chart-axis-scaling" id="chart-axis-scaling"><h2>Chart Axis Scaling</h2></a>
<p>By default, Criterion.rs generates plots using a linear-scale axis. When using parameterized benchmarks, it is common for the input sizes to scale exponentially in order to cover a wide range of possible inputs. In this situation, it may be easier to read the resulting plots with a logarithmic axis.</p>
<p>As with throughput measurements above, this option is only available when using the <code>ParameterizedBenchmark</code> structure.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use criterion::*;

fn do_a_thing(x: u64) {
    // Do something
    ...
}

fn bench(c: &amp;mut Criterion) {
    let plot_config = PlotConfiguration::default()
        .summary_scale(AxisScale::Logarithmic);

    c.bench(
        &quot;log_scale_example&quot;,
        ParameterizedBenchmark::new(
            &quot;do_thing&quot;,
            |b, i| b.iter(|| do_a_thing(i)),
            vec![1u64, 10u64, 100u64, 1000u64, 10000u64, 100000u64, 1000000u64],
        ).plot_config(plot_config),
    );
}

criterion_group!(benches, bench);
criterion_main!(benches);
#}</code></pre></pre>
<p>Currently the axis scaling is the only option that can be set on the
PlotConfiguration struct. More may be added in the future.</p>
<a class="header" href="#comparing-functions" id="comparing-functions"><h1>Comparing Functions</h1></a>
<p>Criterion.rs can automatically benchmark multiple implementations of a function and produce summary graphs to show the differences in performance between them. First, lets create a comparison benchmark.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate criterion;
use criterion::{Criterion, ParameterizedBenchmark}

fn fibonacci_slow(n: u64) -&gt; u64 {
    match n {
        0 =&gt; 1,
        1 =&gt; 1,
        n =&gt; fibonacci_slow(n-1) + fibonacci_slow(n-2),
    }
}

fn fibonacci_fast(n: u64) -&gt; u64 {
    let mut a = 0u64;
    let mut b = 1u64;
    let mut c = 0u64;

    if n == 0 {
        return 0
    }

    for _ in 0..(n+1) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}

fn bench_fibs(c: &amp;mut Criterion) {
    c.bench(
        &quot;Fibonacci&quot;,
        ParameterizedBenchmark::new(&quot;Recursive&quot;, |b, i| b.iter(|| fibonacci_slow(*i)), vec![20u64, 21u64])
            .with_function(&quot;Iterative&quot;, |b, i| b.iter(|| fibonacci_fast(*i))),
    );
}

criterion_group!(benches, bench_fibs);
criterion_main!(benches);
#}</code></pre></pre>
<p>These are the same two fibonacci functions from the <a href="user_guide/../getting_started.html">Getting Started</a> page. The difference here is that we import the <a href="http://bheisler.github.io/criterion.rs/criterion/struct.ParameterizedBenchmark.html">ParameterizedBenchmark type</a> as well.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn bench_fibs(c: &amp;mut Criterion) {
    c.bench(
        &quot;Fibonacci&quot;,
        ParameterizedBenchmark::new(&quot;Recursive&quot;, |b, i| b.iter(|| fibonacci_slow(*i)), vec![2u64, 5, 10, 20])
            .with_function(&quot;Iterative&quot;, |b, i| b.iter(|| fibonacci_fast(*i))),
    );
}
#}</code></pre></pre>
<p>Here, we define a <code>ParameterizedBenchmark</code> which calls the recursive implementation with several
different inputs. We also add a second benchmark which calls the iterative implementation with the
same inputs. This is then passed to the <code>Criterion::bench</code> function, which executes each benchmark
with each input. Criterion will generate a report for each individual benchmark/input pair, as well
as summary reports for each benchmark (across all inputs) and each input (across all benchmarks),
as well as an overall summary of the whole benchmark group.</p>
<p>For benchmarks which do not accept a parameter, there is also the <code>Benchmark</code> struct, which is
identical to <code>ParameterizedBenchmark</code> except it does not accept parameters.</p>
<a class="header" href="#violin-plot" id="violin-plot"><h2>Violin Plot</h2></a>
<p><img src="./violin_plot.svg" alt="Violin Plot" /></p>
<p>The <a href="https://en.wikipedia.org/wiki/Violin_plot">Violin Plot</a> shows the median times and the PDF of
each implementation.</p>
<a class="header" href="#line-chart" id="line-chart"><h2>Line Chart</h2></a>
<p><img src="./lines.svg" alt="Line Chart" /></p>
<p>The line chart shows a comparison of the different functions as the input or input size increases,
which can be enabled with ParameterizedBenchmark.</p>
<a class="header" href="#benchmarking-external-programs" id="benchmarking-external-programs"><h1>Benchmarking External Programs</h1></a>
<p>Criterion.rs has the ability to benchmark external programs (which may be written in any language) the same way that it can benchmark Rust functions. What follows is an example of how that can be done and some of the pitfalls to avoid along the way.</p>
<p>First, let's define our recursive Fibonacci function, only in Python this time:</p>
<pre><code class="language-python">def fibonacci(n):
    if n == 0 or n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2)
</code></pre>
<p>In order to benchmark this with Criterion.rs, we first need to write our own small benchmarking harness. I'll start with the complete code for this and then go over it in more detail:</p>
<pre><code class="language-python">import time
import sys

MILLIS = 1000
MICROS = MILLIS * 1000
NANOS = MICROS * 1000

def benchmark():
    argument = int(sys.argv[1])

    for line in sys.stdin:
        iters = int(line.strip())

        # Setup

        start = time.perf_counter()
        for x in range(iters):
            fibonacci(argument)
        end = time.perf_counter()

        # Teardown

        delta = end - start
        nanos = int(delta * NANOS)
        print(&quot;%d&quot; % nanos)
        sys.stdout.flush()

benchmark()
</code></pre>
<p>The important part is the <code>benchmark()</code> function.</p>
<a class="header" href="#the-argument" id="the-argument"><h3>The Argument</h3></a>
<pre><code class="language-python">argument = int(sys.argv[1])
</code></pre>
<p>This example uses the <code>Criterion::bench_program_over_inputs</code> function to benchmark our Python Fibonacci function with a variety of inputs. The external program recieves the input value as a command-line argument appended to the command specified in the benchmark, so the very first thing our benchmark harness does is parse that argument into an integer. If we used <code>bench_program</code> instead, there would be no argument.</p>
<a class="header" href="#reading-from-stdin" id="reading-from-stdin"><h3>Reading from stdin</h3></a>
<pre><code class="language-python">    for line in sys.stdin:
        iters = int(line.strip())
</code></pre>
<p>Next, our harness reads a line from stdin and parses it into an integer. Starting an external process is slow, and it would mess with our measurements if we had to do so for each iteration of the benchmark. Besides which, it would obscure the results (since we're probably more interested in the performance of the function without the process-creation overhead). Therefore, Criterion.rs starts the process once per input value or benchmark and sends the iteration counts to the external program on stdin. Your external benchmark harness must read and parse this iteration count and call the benchmarked function the appropriate number of times.</p>
<a class="header" href="#setup" id="setup"><h3>Setup</h3></a>
<p>If your benchmarked code requires any setup, this is the time to do that.</p>
<a class="header" href="#timing" id="timing"><h3>Timing</h3></a>
<pre><code class="language-python">        start = time.perf_counter()
        for x in range(iters):
            fibonacci(argument)
        end = time.perf_counter()
</code></pre>
<p>This is the heart of the external benchmark harness. We measure how long it takes to execute our Fibonacci function with the given argument in a loop, iterating the given number of times. It's important here to use the most precise timer available. We'll need to report the measurement in nanoseconds later, so if you can use a timer that returns a value in nanoseconds (eg. Java's <code>System.nanoTime()</code>) we can skip a bit of work later. It's OK if the timer can't measure to nanosecond precision (most PC's can't) but use the best timer you have.</p>
<a class="header" href="#teardown" id="teardown"><h3>Teardown</h3></a>
<p>If your benchmarked code requires any teardown, this is the time to do that.</p>
<a class="header" href="#reporting" id="reporting"><h3>Reporting</h3></a>
<pre><code class="language-python">        delta = end - start
        nanos = int(delta * NANOS)
        print(&quot;%d&quot; % nanos)
        sys.stdout.flush()
</code></pre>
<p>To report the measured time, simply print the elapsed number of nanoseconds to stdout. <code>perf_counter</code> reports its results as a floating-point number of seconds, so we first convert it to an integer number of nanoseconds before printing it.</p>
<p><strong>Beware Buffering:</strong> Criterion.rs will wait until it recieves the measurement before sending the next iteration count. If your benchmarks seem to be hanging during the warmup period, it may be because your benchmark harness is buffering the output on stdout, as Python does here. In this example we explicitly force Python to flush the buffer; you may need to do the same in your benchmarks.</p>
<a class="header" href="#defining-the-benchmark" id="defining-the-benchmark"><h2>Defining the Benchmark</h2></a>
<p>If you've read the earlier pages, this will be quite familiar.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use criterion::Criterion;
use std::process::Command;

fn create_command() -&gt; Command {
    let mut command = Command::new(&quot;python3&quot;);
    command.arg(&quot;benches/external_process.py&quot;);
    command
}

fn python_fibonacci(c: &amp;mut Criterion) {
    c.bench_program_over_inputs(&quot;fibonacci-python&quot;,
        create_command,
        &amp;[1, 2, 4, 8, 16]);
}
#}</code></pre></pre>
<p>As before, we create a <code>Criterion</code> struct and use it to define our benchmark. This time, we use the <code>bench_program_over_inputs</code> method. This takes a function (used to create the <code>Command</code> which represents our external program) and an iterable containing the inputs to test. Aside from the use of a <code>Command</code> rather than a closure, this behaves just like (and produces the same output as) <code>bench_function_over_inputs</code>.</p>
<p>If your benchmark doesn't require input, simply omit the input values and use <code>bench_program</code> instead, which behaves like <code>bench_function</code>.</p>
<a class="header" href="#csv-output" id="csv-output"><h1>CSV Output</h1></a>
<p>Criterion.rs saves its measurements in several files, as shown below:</p>
<pre><code>$BENCHMARK/
├── base/
│  ├── raw.csv
│  ├── estimates.json
│  ├── sample.json
│  └── tukey.json
├── change/
│  └── estimates.json
├── new/
│  ├── raw.csv
│  ├── estimates.json
│  ├── sample.json
│  └── tukey.json
</code></pre>
<p>The JSON files are all considered private implementation details of Criterion.rs, and their
structure may change at any time without warning.</p>
<p>However, there is a need for some sort of stable and machine-readable output to enable projects like
<a href="https://github.com/anp/lolbench">lolbench</a> to keep historical data or perform additional analysis
on the measurements. For this reason, Criterion.rs also writes the <code>raw.csv</code> file. The format of
this file is expected to remain stable between different versions of Criterion.rs, so this file is
suitable for external tools to depend on.</p>
<p>The format of <code>raw.csv</code> is as follows:</p>
<pre><code>group,function,value,sample_time_nanos,iteration_count
Fibonacci,Iterative,,915000,110740
Fibonacci,Iterative,,1964000,221480
Fibonacci,Iterative,,2812000,332220
Fibonacci,Iterative,,3767000,442960
Fibonacci,Iterative,,4785000,553700
Fibonacci,Iterative,,6302000,664440
Fibonacci,Iterative,,6946000,775180
Fibonacci,Iterative,,7815000,885920
Fibonacci,Iterative,,9186000,996660
Fibonacci,Iterative,,9578000,1107400
Fibonacci,Iterative,,11206000,1218140
...
</code></pre>
<p>This data was taken with this benchmark code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn compare_fibonaccis(c: &amp;mut Criterion) {
    let fib_slow = Fun::new(&quot;Recursive&quot;, |b, i| b.iter(|| fibonacci_slow(*i)));
    let fib_fast = Fun::new(&quot;Iterative&quot;, |b, i| b.iter(|| fibonacci_fast(*i)));

    let functions = vec![fib_slow, fib_fast];

    c.bench_functions(&quot;Fibonacci&quot;, functions, 20);
}
#}</code></pre></pre>
<p><code>raw.csv</code> contains the following columns:</p>
<ul>
<li><code>group</code> - This corresponds to the function group name, in this case &quot;Fibonacci&quot; as seen in the
code above. This is the parameter given to the <code>Criterion::bench</code> functions.</li>
<li><code>function</code> - This corresponds to the function name, in this case &quot;Iterative&quot;. When comparing
multiple functions, each function is given a different name. Otherwise, this will be the empty
string.</li>
<li><code>value</code> - This is the parameter passed to the benchmarked function when using parameterized
benchmarks. In this case, there is no parameter so the value is the empty string.</li>
<li><code>iteration_count</code> - The number of times the benchmark was iterated for this sample.</li>
<li><code>sample_time_nanos</code> - The time taken by the measurement for this sample, in nanoseconds. Note
that this is the time for the whole sample, not the time-per-iteration (see
<a href="user_guide/../analysis.html#measurement">Analysis Process</a> for more detail). To calculate the time-per-iteration,
use <code>sample_time_nanos/iteration_count</code>.</li>
</ul>
<p>As you can see, this is the raw measurements taken by the Criterion.rs benchmark process. There is
one record for each sample, and one file for each benchmark.</p>
<p>The results of Criterion.rs' analysis of these measurements are not currently available in
machine-readable form. If you need access to this information, please raise an issue describing
your use case.</p>
<a class="header" href="#known-limitations" id="known-limitations"><h2>Known Limitations</h2></a>
<p>There are currently a number of limitations to the use of Criterion.rs relative to the standard benchmark harness.</p>
<p>First, it is necessary for Criterion.rs to provide its own <code>main</code> function using the <code>criterion_main</code> macro.
This results in several limitations:</p>
<ul>
<li>It is not possible to include benchmarks in code in the <code>src/</code> directory as one might with the regular
benchmark harness.</li>
<li>It is not possible to benchmark non-<code>pub</code> functions. External benchmarks, including those using Criterion.rs,
are compiled as a separate crate, and non-<code>pub</code> functions are not visible to the benchmarks.</li>
<li>It is not possible to benchmark functions in binary crates. Binary crates cannot be dependencies of other
crates, and that includes external tests and benchmarks (<a href="https://github.com/rust-lang/cargo/issues/4316">see here</a> for more details)</li>
</ul>
<p>Criterion.rs cannot currently solve these issues. An <a href="https://github.com/rust-lang/rust/issues/50297">experimental RFC</a> is being implemented to enable custom test and benchmarking frameworks.</p>
<p>Second, Criterion.rs provides a stable-compatible replacement for the <code>black_box</code> function provided by the standard test crate. This replacement is not as reliable as the official one, and it may allow dead-code-elimination to affect the benchmarks in some circumstances. If you're using a Nightly build of Rust, you can add the <code>real_blackbox</code> feature to your dependency on Criterion.rs to use the standard <code>black_box</code> function instead.</p>
<p>Example:</p>
<pre><code class="language-toml">criterion = { version = '...', features=['real_blackbox'] }
</code></pre>
<a class="header" href="#bencher-compatibility-layer" id="bencher-compatibility-layer"><h1>Bencher Compatibility Layer</h1></a>
<p>Criterion.rs provides a small crate which can be used as a drop-in replacement for most common
usages of <code>bencher</code> in order to make it easy for existing <code>bencher</code> users to try out Criterion.rs.
This page shows an example of how to use this crate.</p>
<a class="header" href="#example" id="example"><h2>Example</h2></a>
<p>We'll start with the example benchmark from <code>bencher</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate bencher;

use bencher::Bencher;

fn a(bench: &amp;mut Bencher) {
    bench.iter(|| {
        (0..1000).fold(0, |x, y| x + y)
    })
}

fn b(bench: &amp;mut Bencher) {
    const N: usize = 1024;
    bench.iter(|| {
        vec![0u8; N]
    });

    bench.bytes = N as u64;
}

benchmark_group!(benches, a, b);
benchmark_main!(benches);
#}</code></pre></pre>
<p>The first step is to edit the Cargo.toml file to replace the bencher dependency with
<code>criterion_bencher_compat</code>:</p>
<p>Change:</p>
<pre><code class="language-toml">[dev-dependencies]
bencher = &quot;0.1&quot;
</code></pre>
<p>To:</p>
<pre><code class="language-toml">[dev-dependencies]
criterion_bencher_compat = &quot;0.2&quot;
</code></pre>
<p>Then we update the benchmark file itself to change:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate bencher;
#}</code></pre></pre>
<p>To:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate criterion_bencher_compat as bencher;
#}</code></pre></pre>
<p>That's all! Now just run <code>cargo bench</code>:</p>
<pre><code class="language-text">     Running target/release/deps/bencher_example-d865087781455bd5
a                       time:   [234.58 ps 237.68 ps 241.94 ps]
Found 9 outliers among 100 measurements (9.00%)
  4 (4.00%) high mild
  5 (5.00%) high severe

b                       time:   [23.972 ns 24.218 ns 24.474 ns]
Found 4 outliers among 100 measurements (4.00%)
  4 (4.00%) high mild
</code></pre>
<a class="header" href="#limitations" id="limitations"><h2>Limitations</h2></a>
<p><code>criterion_bencher_compat</code> does not implement the full API of the <code>bencher</code> crate, only the most
commonly-used subset. If your benchmarks require parts of the <code>bencher</code> crate which are not
supported, you may need to temporarily disable them while trying Criterion.rs.</p>
<p><code>criterion_bencher_compat</code> does not provide access to most of Criterion.rs' more advanced features.
If the Criterion.rs benchmarks work well for you, it is recommended to convert your benchmarks to
use the Criterion.rs interface directly. See <a href="user_guide/./migrating_from_libtest.html">Migrating from libtest</a>
for more information on that.</p>
<a class="header" href="#timing-loops" id="timing-loops"><h1>Timing Loops</h1></a>
<p>The <a href="https://bheisler.github.io/criterion.rs/criterion/struct.Bencher.html"><code>Bencher</code></a> structure
provides a number of functions which implement different timing loops for measuring the performance
of a function. This page discusses how these timing loops work and which one is appropriate for
different situations.</p>
<a class="header" href="#iter" id="iter"><h2><code>iter</code></h2></a>
<p>The simplest timing loop is <code>iter</code>. This loop should be the default for most benchmarks. <code>iter</code>
calls the benchmark N times in a tight loop and records the elapsed time for the entire loop.
Because it takes only two measurements (the time before and after the loop) and does nothing else in
the loop <code>iter</code> has effectively zero measurement overhead - meaning it can accurately measure the
performance of functions as small as a single processor instruction.</p>
<p>However, <code>iter</code> has limitations as well. If the benchmark returns a value which implements Drop, it
will be dropped inside the loop and the drop function's time will be included in the measurement.
Additionally, some benchmarks need per-iteration setup. A benchmark for a sorting algorithm
might require some unsorted data to operate on, but we don't want the generation of the unsorted
data to affect the measurement. <code>iter</code> provides no way to do this.</p>
<a class="header" href="#iter_with_large_drop" id="iter_with_large_drop"><h2><code>iter_with_large_drop</code></h2></a>
<p><code>iter_with_large_drop</code> is an answer to the first problem. In this case, the values returned by the
benchmark are collected into a <code>Vec</code> to be dropped after the measurement is complete. This
introduces a small amount of measurement overhead, meaning that the measured value will be slightly
higher than the true runtime of the function. This overhead is almost always negligible, but it's
important to be aware that it exists. Extremely fast benchmarks (such as those in the
hundreds-of-picoseconds range or smaller) or benchmarks that return very large structures may incur
more overhead.</p>
<p>Aside from the measurement overhead, <code>iter_with_large_drop</code> has its own limitations. Collecting the
returned values into a <code>Vec</code> uses heap memory, and the amount of memory used is not under the
control of the user. Rather, it depends on the iteration count which in turn depends on the
benchmark settings and the runtime of the benchmarked function. It is possible that a benchmark
could run out of memory while collecting the values to drop.</p>
<a class="header" href="#iter_batchediter_batched_ref" id="iter_batchediter_batched_ref"><h2><code>iter_batched/iter_batched_ref</code></h2></a>
<p><code>iter_batched</code> and <code>iter_batched_ref</code> are the next step up in complexity for timing loops. These
timing loops take two closures rather than one. The first closure takes no arguments and returns
a value of type <code>T</code> - this is used to generate setup data. For example, the setup function might
clone a vector of unsorted data for use in benchmarking a sorting function. The second closure
is the function to benchmark, and it takes a <code>T</code> (for <code>iter_batched</code>) or <code>&amp;mut T</code> (for
<code>iter_batched_ref</code>).</p>
<p>These two timing loops generate a batch of inputs and measure the time to execute the benchmark on
all values in the batch. As with <code>iter_with_large_drop</code> they also collect the values returned from
the benchmark into a <code>Vec</code> and drop it later without timing the drop. Then another batch of inputs
is generated and the process is repeated until enough iterations of the benchmark have been measured.
Keep in mind that this is only necessary if the benchmark modifies the input - if the input is
constant then one input value can be reused and the benchmark should use <code>iter</code> instead.</p>
<p>Both timing loops accept a third parameter which controls how large a batch is. If the batch size
is too large, we might run out of memory generating the inputs and collecting the outputs. If it's
too small, we could introduce more measurement overhead than is necessary. For ease of use, Criterion
provides three pre-defined choices of batch size, defined by the
<a href="https://bheisler.github.io/criterion.rs/criterion/enum.BatchSize.html"><code>BatchSize</code></a> enum -
<code>SmallInput</code>, <code>LargeInput</code> and <code>PerIteration</code>. It is also possible (though not recommended) to set
the batch size manually.</p>
<p><code>SmallInput</code> should be the default for most benchmarks. It is tuned for benchmarks where the setup
values are small (small enough that millions of values can safely be held in memory) and the output
is likewise small or nonexistent. <code>SmallInput</code> incurs the least measurement overhead (equivalent to
that of <code>iter_with_large_drop</code> and therefore negligible for nearly all benchmarks), but also uses
the most memory.</p>
<p><code>LargeInput</code> should be used if the input or output of the benchmark is large enough that <code>SmallInput</code>
uses too much memory. <code>LargeInput</code> incurs slightly more measurement overhead than <code>SmallInput</code>, but
the overhead is still small enough to be negligible for almost all benchmarks.</p>
<p><code>PerIteration</code> forces the batch size to one. That is, it generates a single setup input, times the
execution of the function once, discards the setup and output, then repeats. This results in a
great deal of measurement overhead - several orders of magnitude more than the other options. It
can be enough to affect benchmarks into the hundreds-of-nanoseconds range. Using <code>PerIteration</code>
should be avoided wherever possible. However, it is sometimes necessary if the input or output of
the benchmark is extremely large or holds a limited resource like a file handle.</p>
<p>Although sticking to the pre-defined settings is strongly recommended, Criterion.rs does allow
users to choose their own batch size if necessary. This can be done with <code>BatchSize::NumBatches</code> or
<code>BatchSize::NumIterations</code>, which specify the number of batches per sample or the number of
iterations per batch respectively. These options should be used only when necessary, as they require
the user to tune the settings manually to get accurate results. However, they are provided as an
option in case the pre-defined options are all unsuitable. <code>NumBatches</code> should be preferred over
<code>NumIterations</code> as it will typically have less measurement overhead, but <code>NumIterations</code> provides
more control over the batch size which may be necessary in some situations.</p>
<a class="header" href="#what-do-i-do-if-my-functions-runtime-is-smaller-than-the-measurement-overhead" id="what-do-i-do-if-my-functions-runtime-is-smaller-than-the-measurement-overhead"><h2>What do I do if my function's runtime is smaller than the measurement overhead?</h2></a>
<p>Criterion.rs' timing loops are carefully designed to minimize the measurement overhead as much as
possible. For most benchmarks the measurement overhead can safely be ignored because the true
runtime of most benchmarks will be very large relative to the overhead. However, benchmarks with a
runtime that is not much larger than the overhead can be difficult to measure.</p>
<p>If you believe that your benchmark is small compared to the measurement overhead, the first option
is to adjust the timing loop to reduce the overhead. Using <code>iter</code> or <code>iter_batched</code> with <code>SmallInput</code>
should be the first choice, as these options incur a minimum of measurement overhead. In general,
using <code>iter_batched</code> with larger batches produces less overhead, so replacing <code>PerIteration</code> with
<code>NumIterations</code> with a suitable batch size will typically reduce the overhead. It is possible for
the batch size to be too large, however, which will increase (rather than decrease) overhead.</p>
<p>If this is not sufficient, the only recourse is to benchmark a larger function. It's tempting to do
this by manually executing the routine a fixed number of times inside the benchmark, but this is
equivalent to what <code>NumIterations</code> already does. The only difference is that Criterion.rs can
account for <code>NumIterations</code> and show the correct runtime for one iteration of the function rather
than many. Instead, consider benchmarking at a higher level.</p>
<p>It's important to stress that measurement overhead only matters for very fast functions which
modify their input. For slower functions (roughly speaking, anything at the nanosecond level or
larger, or the microsecond level for <code>PerIteration</code>, assuming a reasonably modern x86_64 processor
and OS or equivalent) are not meaningfully affected by measurement overhead. For functions which
only read their input and do not modify or consume it, one value can be shared by all iterations
using the <code>iter</code> loop which has effectively no overhead.</p>
<a class="header" href="#deprecated-timing-loops" id="deprecated-timing-loops"><h2>Deprecated Timing Loops</h2></a>
<p>In older Criterion.rs benchmarks (pre 2.10), one might see two more timing loops, called
<code>iter_with_setup</code> and <code>iter_with_large_setup</code>. <code>iter_with_setup</code> is equivalent to <code>iter_batched</code>
with <code>PerIteration</code>. <code>iter_with_large_setup</code> is equivalent to <code>iter_batched</code> with <code>NumBatches(1)</code>.
Both produce much more measurement overhead than <code>SmallInput</code>. Additionally. <code>large_setup</code> also
uses much more memory. Both should be updated to use <code>iter_batched</code>, preferably with <code>SmallInput</code>.
They are kept for backwards-compatibility reasons, but no longer appear in the API documentation.</p>
<a class="header" href="#analysis-process" id="analysis-process"><h1>Analysis Process</h1></a>
<p>This page details the data collection and analysis process used by Criterion.rs. This is a bit more advanced than the user guide; it is assumed the reader is somewhat familiar with statistical concepts. In particular, the reader should know what bootstrap sampling means.</p>
<p>So, without further ado, let's start with a general overview. Each benchmark in Criterion.rs goes through four phases:</p>
<ul>
<li>Warmup - The routine is executed repeatedly to fill the CPU and OS caches and (if applicable) give the JIT time to compile the code</li>
<li>Measurement - The routine is executed repeatedly and the execution times are recorded</li>
<li>Analysis - The recorded samples are analyzed and distilled into meaningful statistics, which are then reported to the user</li>
<li>Comparison - The performance of the current run is compared to the stored data from the last run to determine whether it has changed, and if so by how much</li>
</ul>
<a class="header" href="#warmup-1" id="warmup-1"><h2>Warmup</h2></a>
<p>The first step in the process is warmup. In this phase, the routine is executed repeatedly to give the OS, CPU and JIT time to adapt to the new workload. This helps prevent things like cold caches and JIT compilation time from throwing off the measurements later. The warmup period is controlled by the <code>warm_up_time</code> value in the Criterion struct.</p>
<p>The warmup period is quite simple. The routine is executed once, then twice, four times and so on until the total accumulated execution time is greater than the configured warm up time. The number of iterations that were completed during this period is recorded, along with the elapsed time.</p>
<a class="header" href="#measurement" id="measurement"><h2>Measurement</h2></a>
<p>The measurement phase is when Criterion.rs collects the performance data that will be analyzed and used in later stages. This phase is mainly controlled by the <code>measurement_time</code> value in the Criterion struct.</p>
<p>The measurements are done in a number of samples (see the <code>sample_size</code> parameter). Each sample consists of one or more (typically many) iterations of the routine. The elapsed time between the beginning and the end of the iterations, divided by the number of iterations, gives an estimate of the time taken by each iteration.</p>
<p>As measurement progresses, the sample iteration counts are increased. Suppose that the first sample contains 10 iterations. The second sample will contain 20, the third will contain 30 and so on. More formally, the iteration counts are calculated like so:</p>
<p><code>iterations = [d, 2d, 3d, ... Nd]</code></p>
<p>Where <code>N</code> is the total number of samples and <code>d</code> is a factor, calculated from the rough estimate of iteration time measured during the warmup period, which is used to scale the number of iterations to meet the configured measurement time. Note that <code>d</code> cannot be less than 1, and therefore the actual measurment time may exceed the configured measurement time if the iteration time is large or the configured measurement time is small.</p>
<p>Note that Criterion.rs does not measure each individual iteration, only the complete sample. The resulting samples are stored for use in later stages. The sample data is also written to the local disk so that it can be used in the comparison phase of future benchmark runs.</p>
<a class="header" href="#analysis" id="analysis"><h2>Analysis</h2></a>
<p>During this phase Criterion.rs calculates useful statistics from the samples collected during the measurement phase.</p>
<a class="header" href="#outlier-classification" id="outlier-classification"><h3>Outlier Classification</h3></a>
<p>The first step in analysis is outlier classification. Each sample is classified using a modified version of Tukey's Method, which will be summarized here. First, the interquartile range (IQR) is calculated from the difference between the 25th and 75th percentile. In Tukey's Method, values less than (25th percentile - 1.5 * IQR) or greater than (75th percentile + 1.5 * IQR) are considered outliers. Criterion.rs creates additional fences at (25pct - 3 * IQR) and (75pct + 3 * IQR); values outside that range are considered severe outliers.</p>
<p>Outlier classification is important because the analysis method used to estimate the average iteration time is sensitive to outliers. Thus, when Criterion.rs detects outliers, a warning is printed to inform the user that the benchmark may be less reliable. Additionally, a plot is generated showing which data points are considered outliers, where the fences are, etc.</p>
<p>Note, however, that outlier samples are <em>not</em> dropped from the data, and are used in the following analysis steps along with all other samples.</p>
<a class="header" href="#linear-regression" id="linear-regression"><h3>Linear Regression</h3></a>
<p>The samples collected from a good benchmark should form a rough line when plotted on a chart showing the number of iterations and the time for each sample. The slope of that line gives an estimate of the time per iteration. A single estimate is difficult to interpret, however, since it contains no context. A confidence interval is generally more helpful. In order to generate a confidence interval, a large number of bootstrap samples are generated from the measured samples. A line is fitted to each of the bootstrap samples, and the result is a statistical distribution of slopes that gives a reliable confidence interval around the single estimate calculated from the measured samples.</p>
<p>This resampling process is repeated to generate the mean, standard deviation, median and median absolute deviation of the measured iteration times as well. All of this information is printed to the user and charts are generated. Finally, if there are saved statistics from a previous run, the two benchmark runs are compared.</p>
<a class="header" href="#comparison" id="comparison"><h2>Comparison</h2></a>
<p>In the comparison phase, the statistics calculated from the current benchmark run are compared against those saved by the previous run to determine if the performance has changed in the meantime, and if so, by how much.</p>
<p>Once again, Criterion.rs generates many bootstrap samples, based on the measured samples from the two runs. The new and old bootstrap samples are compared and their T score is calculated using a T-test. The fraction of the bootstrapped T scores which are more extreme than the T score calculated by comparing the two measured samples gives the probability that the observed difference between the two sets of samples is merely by chance. Thus, if that probability is very low or zero, Criterion.rs can be confident that there is truly a difference in execution time between the two samples. In that case, the mean and median differences are bootstrapped and printed for the user, and the entire process begins again with the next benchmark.</p>
<p>This process can be extremely sensitive to changes, especially when combined with a small, highly deterministic benchmark routine. In these circumstances even very small changes (eg. differences in the load from background processes) can change the measurements enough that the comparison process detects an optimization or regression. Since these sorts of unpredictable fluctuations are rarely of interest while benchmarking, there is also a configurable noise threshold. Optimizations or regressions within (for example) +-1% are considered noise and ignored. It is best to benchmark on a quiet computer where possible to minimize this noise, but it is not always possible to eliminate it entirely.</p>
<a class="header" href="#frequently-asked-questions" id="frequently-asked-questions"><h2>Frequently Asked Questions</h2></a>
<a class="header" href="#how-should-i-run-criterionrs-benchmarks-in-a-ci-pipeline" id="how-should-i-run-criterionrs-benchmarks-in-a-ci-pipeline"><h3>How Should I Run Criterion.rs Benchmarks In A CI Pipeline?</h3></a>
<p>Criterion.rs benchmarks can be run as part of a CI pipeline just as they
normally would on the command line - simply run <code>cargo bench</code>.</p>
<p>To compare the master branch to a pull request, you could run the benchmarks on
the master branch to set a baseline, then run them again with the pull request
branch. An example script for Travis-CI might be:</p>
<pre><code class="language-bash">#!/usr/bin/env bash

if [ &quot;${TRAVIS_PULL_REQUEST_BRANCH:-$TRAVIS_BRANCH}&quot; != &quot;master&quot; ] &amp;&amp; [ &quot;$TRAVIS_RUST_VERSION&quot; == &quot;nightly&quot; ]; then
    REMOTE_URL=&quot;$(git config --get remote.origin.url)&quot;;
    cd ${TRAVIS_BUILD_DIR}/.. &amp;&amp; \
    git clone ${REMOTE_URL} &quot;${TRAVIS_REPO_SLUG}-bench&quot; &amp;&amp; \
    cd  &quot;${TRAVIS_REPO_SLUG}-bench&quot; &amp;&amp; \
    # Bench master
    git checkout master &amp;&amp; \
    cargo bench &amp;&amp; \
    # Bench pull request
    git checkout ${TRAVIS_COMMIT} &amp;&amp; \
    cargo bench;
fi
</code></pre>
<p>(Thanks to <a href="https://beachape.com/blog/2016/11/02/rust-performance-testing-on-travis-ci/">BeachApe</a> for the script on which this is based.)</p>
<p>Note that cloud CI providers like Travis-CI and Appveyor introduce a great deal
of noise into the benchmarking process. For example, unpredictable load on the
physical hosts of their build VM's. Benchmarks measured on such services tend
to be unreliable, so you should be skeptical of the results. In particular,
benchmarks that detect performance regressions should not cause the build to
fail, and apparent performance regressions should be verified manually before
rejecting a pull request.</p>
<a class="header" href="#cargo-bench-gives-unrecognized-option-errors-for-valid-command-line-options" id="cargo-bench-gives-unrecognized-option-errors-for-valid-command-line-options"><h3><code>cargo bench</code> Gives &quot;Unrecognized Option&quot; Errors for Valid Command-line Options</h3></a>
<p>By default, Cargo implicitly adds a <code>libtest</code> benchmark harness to your crate when benchmarking, to
handle any <code>#[bench]</code> functions, even if you have none. It compiles and runs this executable first,
before any of the other benchmarks. Normally, this is fine - it detects that there are no <code>libtest</code>
benchmarks to execute and exits, allowing Cargo to move on to the real benchmarks. Unfortunately,
it checks the command-line arguments first, and panics when it finds one it doesn't understand.
This causes Cargo to stop benchmarking early, and it never executes the Criterion.rs benchmarks.</p>
<p>This will occur when running <code>cargo bench</code> with any argument that Criterion.rs supports but <code>libtest</code>
does not. For example, <code>--verbose</code> and <code>--save-baseline</code> will cause this issue, while <code>--help</code> will
not. There are two ways to work around this at present:</p>
<p>You could run only your Criterion benchmark, like so:</p>
<p><code>cargo bench --bench my_benchmark -- --verbose</code></p>
<p>Note that <code>my_benchmark</code> here corresponds to the name of your benchmark in your
<code>Cargo.toml</code> file.</p>
<p>Another option is to disable benchmarks for your lib or app crate. For example,
for library crates, you could add this to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[lib]
bench = false
</code></pre>
<p>Of course, this only works if you define all of your benchmarks in the
<code>benches</code> directory.</p>
<p>See <a href="https://github.com/rust-lang/rust/issues/47241">Rust Issue #47241</a> for
more details.</p>
<a class="header" href="#how-should-i-benchmark-small-functions" id="how-should-i-benchmark-small-functions"><h3>How Should I Benchmark Small Functions?</h3></a>
<p>Exactly the same way as you would benchmark any other function.</p>
<p>It is sometimes suggested that benchmarks of small (nanosecond-scale) functions should iterate the
function to be benchmarked many times internally to reduce the impact of measurement overhead.
This is <em>not</em> required with Criterion.rs, and it is not recommended.</p>
<p>To see this, consider the following benchmark:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn compare_small(c: &amp;mut Criterion) {
    use criterion::black_box;
    use criterion::ParameterizedBenchmark;

    c.bench(
        &quot;small&quot;,
        ParameterizedBenchmark::new(&quot;unlooped&quot;, |b, i| b.iter(|| i + 10), vec![10])
            .with_function(&quot;looped&quot;, |b, i| b.iter(|| {
                for _ in 0..10000 {
                    black_box(i + 10);
                }
            }))
    );
}
#}</code></pre></pre>
<p>This benchmark simply adds two numbers - just about the smallest function that could be performed.
On my computer, this produces the following output:</p>
<pre><code>small/unlooped          time:   [270.00 ps 270.78 ps 271.56 ps]
Found 2 outliers among 100 measurements (2.00%)
  2 (2.00%) high severe
small/looped            time:   [2.7051 us 2.7142 us 2.7238 us]
Found 5 outliers among 100 measurements (5.00%)
  3 (3.00%) high mild
  2 (2.00%) high severe
</code></pre>
<p>2.714 microseconds/10000 gives 271.4 picoseconds, or pretty much the same result. Interestingly,
this is slightly more than one cycle of my 4th-gen Core i7's maximum clock frequency of 4.4 GHz,
which shows how good the pipelining is on modern CPUs. Regardless, Criterion.rs is able to
accurately measure functions all the way down to single instructions. See the <a href="./analysis.html">Analysis
Process</a> page for more details on how Criterion.rs performs its measurements, or see
the <a href="./user_guide/timing_loops.html">Timing Loops</a> page for details on choosing a timing loop to minimize
measurement overhead.</p>
<a class="header" href="#when-should-i-use-criterionblack_box" id="when-should-i-use-criterionblack_box"><h3>When Should I Use <code>criterion::black_box</code>?</h3></a>
<p><code>black_box</code> is a function which prevents certain compiler optimizations. Benchmarks are often
slightly artificial in nature and the compiler can take advantage of that to generate faster code
when compiling the benchmarks than it would in real usage. In particular, it is common for
benchmarked functions to be called with constant parameters, and in some cases rustc can
evaluate the function entirely at compile time and replace the function call with a constant.
This can produce unnaturally fast benchmarks that don't represent how some code would perform
when called normally. Therefore, it's useful to black-box the constant input to prevent this
optimization.</p>
<p>However, you might have a function which you expect to be called with one or more constant
parameters. In this case, you might want to write your benchmark to represent that scenario instead,
and allow the compiler to optimize the constant parameters.</p>
<p>For the most part, Criterion.rs handles this for you - if you use parameterized benchmarks, the
parameters are automatically black-boxed by Criterion.rs so you don't need to do anything. If you're
writing an un-parameterized benchmark of a function that takes an argument, however, this may be
worth considering.</p>
<a class="header" href="#cargo-prints-a-warning-about-explicit-bench-sections-in-cargotoml" id="cargo-prints-a-warning-about-explicit-bench-sections-in-cargotoml"><h3>Cargo Prints a Warning About Explicit [[bench]] Sections in Cargo.toml</h3></a>
<p>Currently, Cargo treats any <code>*.rs</code> file in the <code>benches</code> directory as a
benchmark, unless there are one or more <code>[[bench]]</code> sections in the
<code>Cargo.toml</code> file. In that case, the auto-discovery is disabled
entirely.</p>
<p>In Rust 2018 edition, Cargo will be changed so that <code>[[bench]]</code> no longer
disables the auto-discovery. If your <code>benches</code> directory contains source files
that are not benchmarks, this could break your build when you update, as Cargo
will attempt to compile them as benchmarks and fail.</p>
<p>There are two ways to prevent this breakage from happening. You can explicitly
turn off the autodiscovery like so:</p>
<pre><code class="language-toml">[[package]]
autobenches = false
</code></pre>
<p>The other option is to move those non-benchmark files to a subdirectory (eg.
<code>benches/benchmark_code</code>) where they will no longer be detected as benchmarks.
I would recommend the latter option.</p>
<p>Note that a file which contains a <code>criterion_main!</code> is a valid benchmark and can
safely stay where it is.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
